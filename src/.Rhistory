labs(title = paste("Boxplot of", var), x = "Observations", y = var))
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, boxplots))
par(mfrow=c(2, 2))
# Inicializar el dataframe vacío con los cuantiles
df_qs <- data.frame(Q1 = numeric(length(numeric_attributes)),
Q2 = numeric(length(numeric_attributes)),
Q3 = numeric(length(numeric_attributes)),
O_up = numeric(length(numeric_attributes)),
O_down = numeric(length(numeric_attributes)),
row.names = numeric_attributes)
# Definir la función para calcular las estadísticas
qs <- function(var) {
quantiles <- quantile(cvd[[var]])
iqr <- IQR(cvd[[var]])
Q1 <- quantiles["25%"]
Q2 <- quantiles["50%"]
Q3 <- quantiles["75%"]
O_up <- Q3 + (1.5*iqr)
O_down <- Q1 - (1.5*iqr)
# Asignar los resultados a la fila correspondiente de df_mmm
df_qs[var, ] <<- c(Q1 = Q1, Q2 = Q2, Q3 = Q3, O_up = O_up, O_down = O_down)
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, qs))
df_qs
# Función para crear un boxplot para cada variable
hists <- function(var) {
print(
ggplot(cvd, aes_string(x = var)) +
geom_histogram(aes(y=..density..), binwidth = 2, color = "black", fill = "white") +
geom_density(alpha = 0.2, fill = "blue") +
labs(title = paste("Histogram of", var), x = "Values", y = "Density") +
geom_vline(xintercept = mean(cvd[[var]], na.rm = TRUE), color = "red") +
geom_vline(xintercept = median(cvd[[var]], na.rm = TRUE), color = "forestgreen")
)
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, hists))
df_sk <- data.frame(skew = numeric(length(numeric_attributes)),
kur = numeric(length(numeric_attributes)),
row.names = numeric_attributes)
# Definir la función para calcular las estadísticas
sk <- function(var) {
skew <- skewness(cvd[[var]])
kur <- kurtosis(cvd[[var]])
# Asignar los resultados a la fila correspondiente de df_mmm
df_sk[var, ] <<- c(skew = skew , kur = kur)
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, sk))
df_sk
cvd$bmi <- cvd$weight/((cvd$height/100)**2)
cvd$pulse <- cvd$ap_hi - cvd$ap_lo
head(cvd)
numeric_attributes <- c("age_year","height","weight","ap_hi","ap_lo", "bmi", "pulse")
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, mmm))
# Ver el resultado
df_mmm
par(mfrow=c(2, 2))
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, qs))
df_qs
invisible(lapply(c("bmi", "pulse"), boxplots))
cvd_original <- cvd
cvd <- subset(cvd, (cvd$bmi <= 39.74288 & cvd$bmi >= 14.35445) & (cvd$pulse <= 65 & cvd$pulse >= 25))
print("bmi")
max(cvd$bmi)
min(cvd$bmi)
print("pulse")
max(cvd$pulse)
min(cvd$pulse)
cvd$pulse_clasification <- findInterval(cvd$pulse, c(0, 30, 40, 50, 66))
head(cvd)
# Función para crear un boxplot para cada variable
hists <- function(var) {
print(
ggplot(cvd, aes_string(x = var)) +
geom_histogram(aes(y=..density..), binwidth = 2, color = "black", fill = "white") +
geom_density(alpha = 0.2, fill = "blue") +
labs(title = paste("Histogram of", var), x = "Values", y = "Density") +
geom_vline(xintercept = mean(cvd[[var]], na.rm = TRUE), color = "red") +
geom_vline(xintercept = median(cvd[[var]], na.rm = TRUE), color = "forestgreen")
)
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, hists))
par(mfrow = c(2,2))
caracteristica<-"Sepal.Width"
qqnorm(iris[iris$Species == "versicolor",caracteristica], main = "versicolor")
qqline(iris[iris$Species == "versicolor",caracteristica])
# Función para crear un boxplot para cada variable
hists <- function(var) {
print(
qqnorm(cvd[[var]])
qqline(cvd[[var]])
par(mfrow = c(2,2))
# Función para crear un boxplot para cada variable
hists <- function(var) {
print(
qqnorm(cvd[[var]])
qqline(cvd[[var]])
par(mfrow = c(2,2))
# Función para crear un boxplot para cada variable
hists <- function(var) {
qqnorm(cvd[[var]])
qqline(cvd[[var]])
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, hists))
par(mfrow = c(2,2))
# Función para crear un boxplot para cada variable
hists <- function(var) {
qqnorm(cvd[[var]], main = var)
qqline(cvd[[var]])
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, hists))
par(mfrow = c(2,2))
# Función para crear un boxplot para cada variable
qq <- function(var) {
qqnorm(cvd[[var]], main = var)
qqline(cvd[[var]])
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, qq))
par(mfrow = c(2,2))
# Función para crear un boxplot para cada variable
qq <- function(var) {
qqnorm(cvd[[var]], main = var)
qqline(cvd[[var]])
lillie.test(cvd[[var]])
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, qq))
library(ggplot2)
# Usamos una librería especializada para coeficiente de asimetría
library(moments)
library(qdap) # manipulacion de datos
library(e1071) # asimetría
library(bestNormalize) # transformación de datos
library(fitdistrplus) # gráfica Cullen-Frey
library(dslabs) # datos PCA
library(factoextra) # gráficas PCA
library(nortest)
par(mfrow = c(2,2))
# Función para crear un boxplot para cada variable
qq <- function(var) {
qqnorm(cvd[[var]], main = var)
qqline(cvd[[var]])
lillie.test(cvd[[var]])
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, qq))
par(mfrow = c(2,2))
# Función para crear un boxplot para cada variable
qq <- function(var) {
qqnorm(cvd[[var]], main = var)
qqline(cvd[[var]])
print(
lillie.test(cvd[[var]])
)
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, qq))
par(mfrow = c(2,2))
# Función para crear un boxplot para cada variable
qq <- function(var) {
qqnorm(cvd[[var]], main = var)
qqline(cvd[[var]])
print(
paste(var, lillie.test(cvd[[var]])
)
)
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, qq))
nor <- lillie.test(cvd$height)
View(nor)
nor[2]
nor$p.value
par(mfrow = c(2,2))
# Función para crear un boxplot para cada variable
qq <- function(var) {
qqnorm(cvd[[var]], main = var)
qqline(cvd[[var]])
nor <- lillie.test(cvd[[var]])
paste(var ,nor$p.value)
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, qq))
par(mfrow = c(2,2))
# Función para crear un boxplot para cada variable
qq <- function(var) {
qqnorm(cvd[[var]], main = var)
qqline(cvd[[var]])
nor <- lillie.test(cvd[[var]])
print(
paste(var,nor$p.value)
)
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, qq))
par(mfrow = c(2,2))
# Función para crear un boxplot para cada variable
qq <- function(var) {
qqnorm(cvd[[var]], main = var)
qqline(cvd[[var]])
nor <- lillie.test(cvd[[var]])
print(
paste(var,"pvalue:", nor$p.value)
)
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, qq))
qq <- function(var) {
descdist(cvd[[var]])
descdist(cvd[[var]])
}
dist <- function(var) {
descdist(cvd[[var]])
descdist(cvd[[var]])
}
invisible(lapply(numeric_attributes, dist))
?descdist
dist <- function(var) {
descdist(cvd[[var]], main = paste("Distribución de", var))
}
invisible(lapply(numeric_attributes, dist))
dist <- function(var) {
descdist(cvd[[var]], main = paste("Distribución de", var))
}
invisible(lapply(numeric_attributes, dist))
dist <- function(var) {
descdist(cvd[[var]])
title(main = paste("Distribución de", var))
}
invisible(lapply(numeric_attributes, dist))
dist <- function(var) {
plot.new()  # Crear un nuevo gráfico vacío
title(main = paste("Distribución de", var))  # Agregar el título
descdist(cvd[[var]], add = TRUE)  # Agregar la gráfica de descdist encima
}
invisible(lapply(numeric_attributes, dist))
dist <- function(var) {
descdist(cvd[[var]], boot = 1000)  # Ejecuta descdist con una muestra de bootstrap
Sys.sleep(0.1)  # Pausa breve para asegurarnos de que la gráfica se ha generado
title(main = paste("Distribución de", var))  # Cambia el título
}
invisible(lapply(numeric_attributes, dist))
dist <- function(var) {
descdist(cvd[[var]], boot = 1000)  # Ejecuta descdist con una muestra de bootstrap
Sys.sleep(0.1)  # Pausa breve para asegurarnos de que la gráfica se ha generado
title(main = paste("\nDistribución de", var))  # Cambia el título
}
invisible(lapply(numeric_attributes, dist))
dist <- function(var) {
descdist(cvd[[var]], boot = 1000)  # Ejecuta descdist con una muestra de bootstrap
Sys.sleep(0.1)  # Pausa breve para asegurarnos de que la gráfica se ha generado
title(main = paste("\n\nDistribución de", var))  # Cambia el título
}
invisible(lapply(numeric_attributes, dist))
par(mfrow = c(2,2))
# Función para crear un boxplot para cada variable
qq <- function(var) {
qqnorm(cvd[[var]], main = var)
qqline(cvd[[var]])
ks.test(cvd[[var]], pnorm, mean(cvd[[var]]), sd(cvd[[var]]))
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, qq))
par(mfrow = c(2,2))
# Función para crear un boxplot para cada variable
qq <- function(var) {
qqnorm(cvd[[var]], main = var)
qqline(cvd[[var]])
nor <- lillie.test(cvd[[var]])
print(
paste(var,"pvalue:", nor$p.value)
)
}
# Aplicar la función a cada elemento de numeric_attributes
invisible(lapply(numeric_attributes, qq))
t.sne <- tsne(cvd$x, initial_dims = 2)
library(ggplot2)
# Usamos una librería especializada para coeficiente de asimetría
library(moments)
library(qdap) # manipulacion de datos
library(e1071) # asimetría
library(bestNormalize) # transformación de datos
library(fitdistrplus) # gráfica Cullen-Frey
library(dslabs) # datos PCA
library(factoextra) # gráficas PCA
library(nortest)
library(Rtsne)
library(umap)
t.sne <- tsne(cvd$x, initial_dims = 2)
library(ggplot2)
# Usamos una librería especializada para coeficiente de asimetría
library(moments)
library(qdap) # manipulacion de datos
library(e1071) # asimetría
library(bestNormalize) # transformación de datos
library(fitdistrplus) # gráfica Cullen-Frey
library(dslabs) # datos PCA
library(factoextra) # gráficas PCA
library(nortest)
library(Rtsne)
library(umap)
t.sne <- tsne(cvd$x, initial_dims = 2)
library(ggplot2)
# Usamos una librería especializada para coeficiente de asimetría
library(moments)
library(qdap) # manipulacion de datos
library(e1071) # asimetría
library(bestNormalize) # transformación de datos
library(fitdistrplus) # gráfica Cullen-Frey
library(dslabs) # datos PCA
library(factoextra) # gráficas PCA
library(nortest)
library(tsne)
library(ggplot2)
# Usamos una librería especializada para coeficiente de asimetría
library(moments)
library(qdap) # manipulacion de datos
library(e1071) # asimetría
library(bestNormalize) # transformación de datos
library(fitdistrplus) # gráfica Cullen-Frey
library(dslabs) # datos PCA
library(factoextra) # gráficas PCA
library(nortest)
library(tsne)
install.packages("tsne")
library(ggplot2)
# Usamos una librería especializada para coeficiente de asimetría
library(moments)
library(qdap) # manipulacion de datos
library(e1071) # asimetría
library(bestNormalize) # transformación de datos
library(fitdistrplus) # gráfica Cullen-Frey
library(dslabs) # datos PCA
library(factoextra) # gráficas PCA
library(nortest)
library(tsne)
library(umap)
t.sne <- tsne(cvd$x, initial_dims = 2)
head(cvd)
library(ggplot2)
# Usamos una librería especializada para coeficiente de asimetría
library(moments)
library(qdap) # manipulacion de datos
library(e1071) # asimetría
library(bestNormalize) # transformación de datos
library(fitdistrplus) # gráfica Cullen-Frey
library(dslabs) # datos PCA
library(factoextra) # gráficas PCA
library(nortest)
library(Rtsne)
library(umap)
# 1. Selección de columnas numéricas relevantes (excluyendo `id`)
data_for_tsne <- df[, c("age_days", "age_year", "height", "weight", "ap_hi", "ap_lo",
"cholesterol", "gluc", "smoke", "alco", "active", "bmi", "pulse")]
# 1. Selección de columnas numéricas relevantes (excluyendo `id`)
data_for_tsne <- cvd[, c("age_days", "age_year", "height", "weight", "ap_hi", "ap_lo",
"cholesterol", "gluc", "smoke", "alco", "active", "bmi", "pulse")]
# 2. Escalado de datos
data_scaled <- scale(data_for_tsne)
# 3. Aplicación de t-SNE
set.seed(42)  # para reproducibilidad
tsne_results <- Rtsne(data_scaled, dims = 2, perplexity = 30, verbose = TRUE, max_iter = 500)
# 1. Selección de columnas numéricas relevantes (excluyendo `id`)
data_for_tsne <- df[, c("age_days", "age_year", "height", "weight", "ap_hi", "ap_lo",
"cholesterol", "gluc", "smoke", "alco", "active", "bmi", "pulse")]
# 1. Selección de columnas numéricas relevantes (excluyendo `id`)
data_for_tsne <- cvd[, c("age_days", "age_year", "height", "weight", "ap_hi", "ap_lo",
"cholesterol", "gluc", "smoke", "alco", "active", "bmi", "pulse")]
# 2. Escalado de datos
data_scaled <- scale(data_for_tsne)
# 3. Eliminación de filas duplicadas
data_scaled <- data_scaled[!duplicated(data_scaled), ]
# 4. Aplicación de t-SNE
set.seed(42)  # para reproducibilidad
tsne_results <- Rtsne(data_scaled, dims = 2, perplexity = 30, verbose = TRUE, max_iter = 500)
# 5. Visualización de los resultados
tsne_data <- data.frame(tsne_results$Y)
colnames(tsne_data) <- c("tSNE_1", "tSNE_2")
tsne_data$cardio <- df$cardio[!duplicated(data_scaled)]  # Asegúrate de que el tamaño coincida
# 1. Selección de columnas numéricas relevantes (excluyendo `id`)
data_for_tsne <- cvd[, c("age_days", "age_year", "height", "weight", "ap_hi", "ap_lo",
"cholesterol", "gluc", "smoke", "alco", "active", "bmi", "pulse")]
# 2. Escalado de datos
data_scaled <- scale(data_for_tsne)
# 3. Eliminación de filas duplicadas
data_scaled <- data_scaled[!duplicated(data_scaled), ]
# 4. Aplicación de t-SNE
set.seed(42)  # para reproducibilidad
tsne_results <- Rtsne(data_scaled, dims = 2, perplexity = 30, verbose = TRUE, max_iter = 500)
# 5. Visualización de los resultados
tsne_data <- data.frame(tsne_results$Y)
colnames(tsne_data) <- c("tSNE_1", "tSNE_2")
tsne_data$cardio <- cvd$cardio[!duplicated(data_scaled)]  # Asegúrate de que el tamaño coincida
# 1. Selección de columnas numéricas relevantes (excluyendo `id`)
data_for_tsne <- df[, c("age_days", "age_year", "height", "weight", "ap_hi", "ap_lo",
"cholesterol", "gluc", "smoke", "alco", "active", "bmi", "pulse")]
# 1. Selección de columnas numéricas relevantes (excluyendo `id`)
data_for_tsne <- cvd[, c("age_days", "age_year", "height", "weight", "ap_hi", "ap_lo",
"cholesterol", "gluc", "smoke", "alco", "active", "bmi", "pulse")]
# 2. Escalado de datos
data_scaled <- scale(data_for_tsne)
# 3. Creación de un índice lógico para las filas no duplicadas
non_duplicates_index <- !duplicated(data_scaled)
# 4. Eliminación de filas duplicadas
data_scaled <- data_scaled[non_duplicates_index, ]
# 5. Aplicación de t-SNE
set.seed(42)  # para reproducibilidad
tsne_results <- Rtsne(data_scaled, dims = 2, perplexity = 30, verbose = TRUE, max_iter = 500)
# 6. Crear un data frame solo con los resultados de t-SNE
tsne_data <- data.frame(tsne_results$Y)
colnames(tsne_data) <- c("tSNE_1", "tSNE_2")
tsne_data$cardio <- cvd$cardio[non_duplicates_index]  # Usar el índice de no duplicados
# 7. Graficar usando ggplot2
ggplot(tsne_data, aes(x = tSNE_1, y = tSNE_2, color = as.factor(cardio))) +
geom_point(alpha = 0.7) +
labs(color = "Cardio", title = "t-SNE de los datos") +
theme_minimal()
UMAP <- umap(tissue_gene_expression$x)
UMAP
head(UMAP$layout, 3) # layout es la matriz con coordenadas
layout <- data.frame(UMAP$layout)
layout$tissues <-  tissue_gene_expression$y
fig <- plot_ly(layout, x = ~X1, y = ~X2, color = ~layout$tissues, type = 'scatter', mode = 'markers')
# 1. Selección de columnas numéricas relevantes (excluyendo `id`)
data_for_umap <- df[, c("age_days", "age_year", "height", "weight", "ap_hi", "ap_lo",
"cholesterol", "gluc", "smoke", "alco", "active", "bmi", "pulse")]
# 1. Selección de columnas numéricas relevantes (excluyendo `id`)
data_for_umap <- cvd[, c("age_days", "age_year", "height", "weight", "ap_hi", "ap_lo",
"cholesterol", "gluc", "smoke", "alco", "active", "bmi", "pulse")]
# 2. Escalado de datos
data_scaled <- scale(data_for_umap)
# 3. Eliminación de filas duplicadas
data_scaled <- data_scaled[!duplicated(data_scaled), ]
# 4. Aplicación de UMAP
library(umap)
set.seed(42)  # para reproducibilidad
umap_results <- umap(data_scaled)
# 5. Crear un data frame con los resultados de UMAP
umap_data <- data.frame(umap_results$layout)
colnames(umap_data) <- c("UMAP_1", "UMAP_2")
umap_data$cardio <- cvd$cardio[!duplicated(data_scaled)]  # Asegúrate de que el tamaño coincida
# 1. Selección de columnas numéricas relevantes (excluyendo `id`)
data_for_umap <- cvd[, c("age_days", "age_year", "height", "weight", "ap_hi", "ap_lo",
"cholesterol", "gluc", "smoke", "alco", "active", "bmi", "pulse")]
# 2. Escalado de datos
data_scaled <- scale(data_for_umap)
# 3. Eliminación de filas duplicadas
data_scaled <- data_scaled[!duplicated(data_scaled), ]
# 4. Aplicación de UMAP
library(umap)
set.seed(42)  # para reproducibilidad
umap_results <- umap(data_scaled)
# 5. Crear un data frame con los resultados de UMAP
umap_data <- data.frame(umap_results$layout)
colnames(umap_data) <- c("UMAP_1", "UMAP_2")
umap_data$cardio <- cvd$cardio[non_duplicates_index]  # Asegúrate de que el tamaño coincida
# 6. Graficar usando ggplot2
library(ggplot2)
ggplot(umap_data, aes(x = UMAP_1, y = UMAP_2, color = as.factor(cardio))) +
geom_point(alpha = 0.7) +
labs(color = "Cardio", title = "UMAP de los datos") +
theme_minimal()
# 1. Selección de columnas numéricas relevantes (excluyendo `id`)
data_for_tsne <- cvd[, c("age_year", "height", "weight", "ap_hi", "ap_lo", "bmi", "pulse")]
# 2. Escalado de datos
data_scaled <- scale(data_for_tsne)
# 3. Creación de un índice lógico para las filas no duplicadas
non_duplicates_index <- !duplicated(data_scaled)
# 4. Eliminación de filas duplicadas
data_scaled <- data_scaled[non_duplicates_index, ]
# 5. Aplicación de t-SNE
set.seed(42)  # para reproducibilidad
tsne_results <- Rtsne(data_scaled, dims = 2, perplexity = 30, verbose = TRUE, max_iter = 500)
# 6. Crear un data frame solo con los resultados de t-SNE
tsne_data <- data.frame(tsne_results$Y)
colnames(tsne_data) <- c("tSNE_1", "tSNE_2")
tsne_data$cardio <- cvd$cardio[non_duplicates_index]  # Usar el índice de no duplicados
# 7. Graficar usando ggplot2
ggplot(tsne_data, aes(x = tSNE_1, y = tSNE_2, color = as.factor(cardio))) +
geom_point(alpha = 0.7) +
labs(color = "Cardio", title = "t-SNE de los datos") +
theme_minimal()
# 1. Selección de columnas numéricas relevantes (excluyendo `id`)
data_for_umap <- cvd[, c("age_year", "height", "weight", "ap_hi", "ap_lo", "bmi", "pulse")]
# 2. Escalado de datos
data_scaled <- scale(data_for_umap)
# 3. Eliminación de filas duplicadas
data_scaled <- data_scaled[!duplicated(data_scaled), ]
# 4. Aplicación de UMAP
library(umap)
set.seed(42)  # para reproducibilidad
umap_results <- umap(data_scaled)
# 5. Crear un data frame con los resultados de UMAP
umap_data <- data.frame(umap_results$layout)
colnames(umap_data) <- c("UMAP_1", "UMAP_2")
umap_data$cardio <- cvd$cardio[non_duplicates_index]  # Asegúrate de que el tamaño coincida
# 6. Graficar usando ggplot2
library(ggplot2)
ggplot(umap_data, aes(x = UMAP_1, y = UMAP_2, color = as.factor(cardio))) +
geom_point(alpha = 0.7) +
labs(color = "Cardio", title = "UMAP de los datos") +
theme_minimal()
